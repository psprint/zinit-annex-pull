#!/usr/bin/env zsh
# -*- mode: sh; sh-indentation: 4; indent-tabs-mode: nil; sh-basic-offset: 4; -*-

# Copyright (c) 2022 Sebastian Gniazdowski

# Set the base and typically useful options
emulate -LR zsh
setopt extendedglob warncreateglobal typesetsilent noshortloops rcquotes ${${options[xtrace]:#off}:+xtrace}
typeset -gA Plugins

if [[ $0 != za-pull-handler || -n $ZSH_SCRIPT ]]; then
    # Handle $0 according to the Zsh Plugin Standard:
    # https://zdharma-continuum.github.io/Zsh-100-Commits-Club/Zsh-Plugin-Standard.html
    0=${${ZERO:-${0:#$ZSH_ARGZERO}}:-${(%):-%N}}
    0=${${(M)0##/*}:-$PWD/$0}
fi

# Such global variable is expected to be typeset'd -g in the plugin.zsh
# file. Here it's restored in case of the function being run as a script.
Plugins[PULL_DIR]=${0:h}
Plugins[PULL_TMP]=$(mktemp)

local url=$2 obj
typeset -F3 SECONDS=0
local tmp=$Plugins[PULL_TMP] line
local -a lines
shift 2
wget $url -O $tmp &>/dev/null
# Strip tags, etc.
local file=$(<$tmp)
# Most time consuming part – replaced with `sed`
#local -A map=( "&lt;" "<" "&gt;" ">" )
#print -r -- ${file//(<[^>]#>|\&lt\;|\&gt\;)/$map[$match[1]]} >! $tmp-
tr '\n' '\f' < $tmp | sed -r -e 's/<[^>]*>//gi' -e 's/\&lt\;/</gi' -e 's/\&gt\;/>/gi' -e 's/\&quot\;/"/gi' | \
 tr '\f' '\n' > $tmp-
+zinit-message "{auto}Preprocessing finished after: ${SECONDS}s"

() { fc -p -a $tmp-; lines=( $history[@] ); }

integer next
local bit exts="${(j:|:)${(@)${(@Akons:|:)${ZINIT_EXTS[ice-mods]//\'\'/}}/(#s)<->-/}}"
local -a selected reply
.pull-add-object() {
    local id=$1 line=$2
    id=${id//\//---}
    #print $line >! $ZINIT[OBJECTS_DIR]/$id
    print -- \\n$line >> ~/.zshrc
    +zinit-message "{auto}Object $id successfully added"
}

.pull-get-object-with-ices-from-lines() {
    local -a prevmatch
    local searched=$1 line realline prevline ices
    integer got_line
    shift
    reply=()
    searched=${searched//\*/[[:alnum:].,:_\\+/-]#}
    for line; do
        line=${(j+ +)${${(Z+Cn+@)line}//(#m)([$' \t'])/$'\ua0'}}
        # History read mechanism doesn'tconnect all lines, surprisingly
        if [[ $line == *\\ ]]; then
            realline+=${line%%[$' \t']#\\}\ 
            got_line=0
            continue
        else
            got_line=1
            realline=$line
        fi
        # An interesting trick is being utilized – use
        # of the secondary, doubling negation of Zsh patterns,
        # which are being groundbreaking yet unknown extension
        # to regular expressions – after the token, the one
        # marked with unneded "*", there is the "repel" negation:
        # "~((${ZINIT[..." which repels, blocks all values
        # specified in it, allowing to prevent the parenthesis
        # from matching *local* ices of the object (snippet or
        # plugin).
        if [[ $realline = ([[:space:]]##|(#s))(#b)(zi(#B)(|nit)[$' \t']##((--|)(${~ZINIT[ice-list]}${~exts})([^$' \t']#)[$' \t']##)#)\
for(#B)([$' \t']##((--|)(${~ZINIT[ice-list]}${~exts})([^$' \t']#)[$' \t']##)#\
([^$' \t']##~((${~ZINIT[ice-list]}${~exts})([^$' \t']#))))#\
([$' \t']##(#b)((#B)((--|)(${~ZINIT[ice-list]}${~exts})([^$' \t']#)[$' \t']##)##)\
(#b)($~searched))(#B)([$' \t']##((--|)(${~ZINIT[ice-list]}${~exts})[^$' \t']#[$' \t']##)#\
[^$' \t']##)#* ]]; then
            # 1. Trim leading and trailing whitespace
            # 2. Restore proper spaces over the non-breaking ones
            match=( "${(@)${(@)${(@)${match[@]%%[$' \t']##}##[$' \t']##}//$'\ua0'/ }//\\[[:space:]]#(#e)}" )
            reply+=( "$match[1] $match[2] for $match[3]" "$match[3]")
        elif [[ $realline == ([[:space:]]##|(#s))(#b)zi(|nit)[[:space:]]##\
(load|light|snippet)[[:space:]]##($~searched)(\#*|)  ]]; then
            match=( "${(@)${(@)${(@)${match[@]%%[$' \t']##}##[$' \t']##}//$'\ua0'/ }//\\[[:space:]]#(#e)}" )
            prevmatch=( $match )
            ices=
            if [[ $prevline == ([[:space:]]##|(#s))(#b)zi(|nit)[[:space:]]##\
ice[[:space:]]##(*) ]]; then
                match=( "${(@)${(@)${(@)${match[@]%%[$' \t']##}##[$' \t']##}//$'\ua0'/ }//\\[[:space:]]#(#e)}" )
                ices=$match[2]
            fi

            # Ensure snippet, if needed
            if [[ $prevmatch[2] == snippet ]]; then
                if [[ $prevmatch[3] != (((http|ftp)(s|)|ssh|file)://|OMZ[A-Z]#:|PZT[A-Z]#:)* ]]; then
                    ices+=${ices:+ }is-snippet
                fi
            # Or, ensure plugin, if needed
            else
                if [[ $prevmatch[3] == (((http|ftp)(s|)|ssh|file)://|OMZ[A-Z]#:|PZT[A-Z]#:)* ]]; then
                    ices+=${ices:+ }is-plugin
                fi
            fi

            # Save result
            reply+=( "zinit $ices${ices:+ }for $prevmatch[3]" "$prevmatch[3]" )
        fi

        # Handle previous line variable - store it
        if (( got_line )) && [[ $realline == ([[:space:]]##|(#s))zi(nit)[[:space:]]##ice[[:space:]]##*  ]]; then
            prevline=$realline
        fi
        # Or clear it, if needed
        if [[ $realline == ([[:space:]]##|(#s))zi(nit)[[:space:]]##(load|light|snippet)[[:space:]]##* ]]; then
            prevline=
        fi
    done
}

SECONDS=0
integer count
local answer id

for obj; do
    .pull-get-object-with-ices-from-lines $obj $lines
    selected=( $reply )
    +zinit-message "Found {num}$(($#reply/2)) {rst}objects{ehi}:"
    for line id in $selected; do
        (( count ++ ))
        +zinit-message "{nl}{auto}Object $id ($count): $line"
        +zinit-message "Add ($count) to the load configuration? (y/n)"
        read -qs answer
        if [[ $answer == y ]]; then
            .pull-add-object $id $line
        fi
    done
done
+zinit-message "Swipe finished in ${SECONDS}s"
# vim:ft=zsh:tw=80:sw=4:sts=4:et:foldmarker=[[[,]]]
