#!/usr/bin/env zsh
# -*- mode: sh; sh-indentation: 4; indent-tabs-mode: nil; sh-basic-offset: 4; -*-

# Copyright (c) 2022 Sebastian Gniazdowski

# Set the base and typically useful options
emulate -LR zsh
setopt extendedglob warncreateglobal typesetsilent noshortloops rcquotes ${${options[xtrace]:#off}:+xtrace}
typeset -gA Plugins

if [[ $0 != za-pull-handler || -n $ZSH_SCRIPT ]]; then
    # Handle $0 according to the Zsh Plugin Standard:
    # https://zdharma-continuum.github.io/Zsh-100-Commits-Club/Zsh-Plugin-Standard.html
    0=${${ZERO:-${0:#$ZSH_ARGZERO}}:-${(%):-%N}}
    0=${${(M)0##/*}:-$PWD/$0}
fi

# Such global variable is expected to be typeset'd -g in the plugin.zsh
# file. Here it's restored in case of the function being run as a script.
Plugins[PULL_DIR]=${0:h}
Plugins[PULL_TMP]=$(mktemp)

local url=$2 obj
typeset -F3 SECONDS=0
local tmp=$Plugins[PULL_TMP] line
local -a lines
shift 2
wget $url -O $tmp &>/dev/null
# Strip tags, etc.
local file=$(<$tmp)
# Most time consuming part – replaced with `sed`
#local -A map=( "&lt;" "<" "&gt;" ">" )
#print -r -- ${file//(<[^>]#>|\&lt\;|\&gt\;)/$map[$match[1]]} >! $tmp-
tr '\n' '\f' < $tmp | sed -r -e 's/<[^>]*>//gi' -e 's/\&lt\;/</gi' -e 's/\&gt\;/>/gi' -e 's/\&quot\;/"/gi' | \
 tr '\f' '\n' > $tmp-
+zinit-message "{auto}Preprocessing finished after: ${SECONDS}s"

() { fc -p -a $tmp-; lines=( $history[@] ); }

integer next
local bit exts="${(j:|:)${(@)${(@Akons:|:)${ZINIT_EXTS[ice-mods]//\'\'/}}/(#s)<->-/}}"
local -a selected reply

.pull-get-object-with-ices-from-lines() {
    local searched=$1 line
    shift
    reply=()
    for line; do
        line="${(j: :)${(Z+Cn+@)line}}"
        # An interesting trick is being utilized – use
        # of the secondary, doubling negation of Zsh patterns,
        # which are being groundbreaking yet unknown extension
        # to regular expressions – after the token, the one
        # marked with unneded "*", there is the "repel" negation:
        # "~((${ZINIT[..." which repels, blocks all values
        # specified in it, allowing to prevent the parenthesis
        # from matching *local* ices of the object (snippet or
        # plugin).
        if [[ $line = (#b)*(zi(#B)(|nit)[[:space:]]##((--|)(${~ZINIT[ice-list]}${~exts})([^[:space:]]#)[[:space:]]##)#)\
for(#B)([[:space:]]##((--|)(${~ZINIT[ice-list]}${~exts})([^[:space:]]#)[[:space:]]##)#\
([^[:space:]*]##~((${~ZINIT[ice-list]}${~exts})([^[:space:]]#))))#\
([[:space:]]##(#b)((#B)((--|)(${~ZINIT[ice-list]}${~exts})([^[:space:]]#)[[:space:]]##)##)\
(#b)($~searched))(#B)([[:space:]]##((--|)(${~ZINIT[ice-list]}${~exts})[^[:space:]]#[[:space:]]##)#\
[^[:space:]]##)#* ]]; then
            match=( "${(@)${match[@]%%[[:space:]]##}##[[:space:]]##}" )
            #print -rl -- "match array:" "$match[@]"
            reply+=( "$match[1] $match[2] for $match[3]" )
        fi
    done
}

SECONDS=0

for obj; do
    .pull-get-object-with-ices-from-lines $obj $lines
    selected=( $reply )
    +zinit-message "{auto}Found object: $selected"
done

+zinit-message "Finished in ${SECONDS}s"
# vim:ft=zsh:tw=80:sw=4:sts=4:et:foldmarker=[[[,]]]
