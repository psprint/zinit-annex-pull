#!/usr/bin/env zsh
# -*- mode: sh; sh-indentation: 4; indent-tabs-mode: nil; sh-basic-offset: 4; -*-

# Copyright (c) 2022 Sebastian Gniazdowski

# Set the base and typically useful options
emulate -LR zsh
setopt extendedglob warncreateglobal typesetsilent noshortloops rcquotes ${${options[xtrace]:#off}:+xtrace}
typeset -gA Plugins

if [[ $0 != za-pull-handler || -n $ZSH_SCRIPT ]]; then
    # Handle $0 according to the Zsh Plugin Standard:
    # https://zdharma-continuum.github.io/Zsh-100-Commits-Club/Zsh-Plugin-Standard.html
    0=${${ZERO:-${0:#$ZSH_ARGZERO}}:-${(%):-%N}}
    0=${${(M)0##/*}:-$PWD/$0}
fi

# Such global variable is expected to be typeset'd -g in the plugin.zsh
# file. Here it's restored in case of the function being run as a script.
Plugins[PULL_DIR]=${0:h}
Plugins[PULL_TMP]=$(mktemp)

local url=$2 obj
typeset -F3 SECONDS=0
local tmp=$Plugins[PULL_TMP] line
local -a lines
shift 2
wget $url -O $tmp &>/dev/null
# Strip tags, etc.
local file=$(<$tmp)
# Most time consuming part – replaced with `sed`
#local -A map=( "&lt;" "<" "&gt;" ">" )
#print -r -- ${file//(<[^>]#>|\&lt\;|\&gt\;)/$map[$match[1]]} >! $tmp-
tr '\n' '\f' < $tmp | sed -r -e 's/<[^>]*>//gi' -e 's/\&lt\;/</gi' -e 's/\&gt\;/>/gi' -e 's/\&quot\;/"/gi' | \
 tr '\f' '\n' > $tmp-
+zinit-message "{auto}Preprocessing finished after: ${SECONDS}s"

() { fc -p -a $tmp-; lines=( $history[@] ); }

integer next
local bit exts="${(j:|:)${(@)${(@Akons:|:)${ZINIT_EXTS[ice-mods]//\'\'/}}/(#s)<->-/}}"
local -a selected reply
.pull-add-object() {
    local id=$1 line=$2
    id=${id//\//---}
    print $line >! $ZINIT[OBJECTS_DIR]/$id
    +zinit-message "{auto}Object $id successfully added"
}

.pull-get-object-with-ices-from-lines() {
    selected=( $reply )
    local searched=$1 line realline
    shift
    reply=()
    searched=${searched//\*/[[:alnum:].,:_\\+-]##}
    for line; do
        line=${(j+ +)${${(Z+Cn+@)line}//(#m)([$' \t'])/$'\ua0'}}
        # History read mechanism doesn'tconnect all lines, surprisingly
        if [[ $line == *\\ ]]; then
            realline+=${line%%[[:space:]]#\\}\ 
            continue
        else
            realline=$line
        fi
        # An interesting trick is being utilized – use
        # of the secondary, doubling negation of Zsh patterns,
        # which are being groundbreaking yet unknown extension
        # to regular expressions – after the token, the one
        # marked with unneded "*", there is the "repel" negation:
        # "~((${ZINIT[..." which repels, blocks all values
        # specified in it, allowing to prevent the parenthesis
        # from matching *local* ices of the object (snippet or
        # plugin).
        if [[ $realline = (#b)*(zi(#B)(|nit)[[:space:]]##((--|)(${~ZINIT[ice-list]}${~exts})([^[:space:]]#)[[:space:]]##)#)\
for(#B)([[:space:]]##((--|)(${~ZINIT[ice-list]}${~exts})([^[:space:]]#)[[:space:]]##)#\
([^[:space:]*]##~((${~ZINIT[ice-list]}${~exts})([^[:space:]]#))))#\
([[:space:]]##(#b)((#B)((--|)(${~ZINIT[ice-list]}${~exts})([^[:space:]]#)[[:space:]]##)##)\
(#b)($~searched))(#B)([[:space:]]##((--|)(${~ZINIT[ice-list]}${~exts})[^[:space:]]#[[:space:]]##)#\
[^[:space:]]##)#* ]]; then
            match=( "${${(@)${match[@]%%[[:space:]]##}##[[:space:]]##}//$'\ua0'/ }" )
            reply+=( "$match[1] $match[2] for $match[3]" $match[3])
        fi
    done
}

SECONDS=0
integer count
local answer id

for obj; do
    .pull-get-object-with-ices-from-lines $obj $lines
    selected=( $reply )
    for line id in $selected; do
        (( count ++ ))
        +zinit-message "{auto}Object $id ($count): $line"
        +zinit-message "Add ($count) to the load configuration? (y/n)"
        read -qs answer
        if [[ $answer == y ]]; then
            .pull-add-object $id $line
        fi
    done
done
+zinit-message "Swipe finished in ${SECONDS}s"
# vim:ft=zsh:tw=80:sw=4:sts=4:et:foldmarker=[[[,]]]
